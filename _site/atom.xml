<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Levey</title>
 <link href="http://levey.github.com/atom.xml" rel="self"/>
 <link href="http://levey.github.com/"/>
 <updated>2012-12-20T17:52:12+08:00</updated>
 <id>http://levey.github.com/</id>
 <author>
   <name>Levey</name>
   <email>levey.zhu@gmail.com</email>
 </author>

 
 <entry>
   <title>Delegate vs Blcok vs Notification vs KVO</title>
   <link href="http://levey.github.com/blog/2012/12/20/delegate-vs-blcok-vs-notification-vs-kvo.html"/>
   <updated>2012-12-20T00:00:00+08:00</updated>
   <id>http://levey.github.com/blog/2012/12/20/delegate-vs-blcok-vs-notification-vs-kvo</id>
   <content type="html">&lt;p&gt;最近在工作中遇到对使用 Delegate 和 Notification 的争议，我写下了自己的观点。&lt;/p&gt;

&lt;h4 id='delegate'&gt;Delegate&lt;/h4&gt;

&lt;h5 id='id18'&gt;好处&lt;/h5&gt;

&lt;p&gt;语法严格，所有方法必须被定义。&lt;/p&gt;

&lt;p&gt;编译期的检查，Warning 或者 Error。&lt;/p&gt;

&lt;p&gt;非常容易追踪，DEBUG 或者跳转到定义的时候很方便。&lt;/p&gt;

&lt;h5 id='id19'&gt;坏处&lt;/h5&gt;

&lt;p&gt;写的代码比较多。&lt;/p&gt;

&lt;p&gt;需要检查 delegate 是否为空指针。&lt;/p&gt;

&lt;p&gt;一对多实现困难。&lt;/p&gt;

&lt;h4 id='block'&gt;Block&lt;/h4&gt;

&lt;h5 id='id20'&gt;好处&lt;/h5&gt;

&lt;p&gt;匿名方法，不需要额外定义方法。&lt;/p&gt;

&lt;p&gt;异步处理时的语法直观。&lt;/p&gt;

&lt;h5 id='id21'&gt;坏处&lt;/h5&gt;

&lt;p&gt;需要小心 retain cycle.&lt;/p&gt;

&lt;p&gt;传入 block 的对象需要做处理。&lt;/p&gt;

&lt;h4 id='notification'&gt;Notification&lt;/h4&gt;

&lt;h5 id='id22'&gt;好处&lt;/h5&gt;

&lt;p&gt;实现简单。&lt;/p&gt;

&lt;p&gt;更新多个对象。&lt;/p&gt;

&lt;h5 id='id23'&gt;坏处&lt;/h5&gt;

&lt;p&gt;没有编译时检查。&lt;/p&gt;

&lt;p&gt;在不需要的时候需要注销通知。&lt;/p&gt;

&lt;p&gt;不可追踪（DEBUG）。&lt;/p&gt;

&lt;p&gt;通知的名字需要在 controller 和 observer 都被知道,如果稍有写错,后果不堪。&lt;/p&gt;

&lt;h4 id='kvo'&gt;KVO&lt;/h4&gt;

&lt;h5 id='id24'&gt;好处&lt;/h5&gt;

&lt;p&gt;在2个对象间同步信息很方便。&lt;/p&gt;

&lt;p&gt;能提供一个对象的新的值和旧的值。&lt;/p&gt;

&lt;p&gt;可以 observe 嵌套的对象。&lt;/p&gt;

&lt;h5 id='id25'&gt;坏处&lt;/h5&gt;

&lt;p&gt;被监听的属性是需要用字符串来表示的，没有编译期间检查。&lt;/p&gt;

&lt;p&gt;属性的改动导致 observe 失效。&lt;/p&gt;

&lt;p&gt;在对象销毁的时候需要移除 observer。&lt;/p&gt;

&lt;h4 id='id26'&gt;总结&lt;/h4&gt;

&lt;p&gt;我个人比较倾向于使用 Delegate 和 Block 来在各对象之前交互（在有多个方法的时候我会使用Delegate）在少数需要更新多个对象的使用 Notification 和 KVO.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Objective-C / Node.js 贯穿 iOS app 前后端教程(一)</title>
   <link href="http://levey.github.com/blog/2012/12/13/build-ios-app-with-nodejs-server-1.html"/>
   <updated>2012-12-13T00:00:00+08:00</updated>
   <id>http://levey.github.com/blog/2012/12/13/build-ios-app-with-nodejs-server-1</id>
   <content type="html">&lt;h4 id='id14'&gt;说明&lt;/h4&gt;

&lt;p&gt;这是一篇很基础的教程，全篇通过制作一个叫 WhateverNote 的 app，来描述 iOS app 的前端和服务端交互的。&lt;/p&gt;

&lt;h4 id='__'&gt;语言 / 框架&lt;/h4&gt;

&lt;p&gt;iOS 端用到的语言就是 Objective-C, 为了方便我选择 &lt;a href='https://github.com/AFNetworking/AFNetworking'&gt;AFNetowrking&lt;/a&gt; 作为 HTTP 库 。服务器端本来想用 Ruby on Rails 或者 Sinatra 的，但是后来想试一试 Node.js 的体验，所以就用 Node.js了，选择的 web framework 是 express.js, 跟 Sinatra 是类似的，都比较轻量级。&lt;/p&gt;

&lt;h4 id='id15'&gt;工具&lt;/h4&gt;

&lt;p&gt;iOS: &lt;code&gt;Xcode&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Node.js: &lt;code&gt;Sublime Text 2&lt;/code&gt; / &lt;code&gt; iTerm 2&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id='whatevernote__server'&gt;WhateverNote - Server&lt;/h4&gt;

&lt;p&gt;先从 &lt;a href='http://nodejs.org'&gt;http://nodejs.org&lt;/a&gt; 下载安装 Node.js，我当前的最新稳定版本为 v0.8.15。&lt;/p&gt;

&lt;p&gt;安装 Node.js 成功后，通过终端安装 experess.js, -g 参数表示安装的包为全局的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g express&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 express.js 成功后， 在 WhateverNote 目录下新建一个 Whatever-server 的项目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;express Whatever-server&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入刚建立的项目的目录 执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node app.js &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用浏览器打开 localhost:3000 就能看到 express 的欢迎页面了。&lt;/p&gt;

&lt;p&gt;然后我们看一下 app.js 这个文件，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&amp;#39;express&amp;#39;)
 , routes = require(&amp;#39;./routes&amp;#39;)
 , user = require(&amp;#39;./routes/user&amp;#39;)
 , http = require(&amp;#39;http&amp;#39;)
 , path = require(&amp;#39;path&amp;#39;);

var app = express();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是一些变量，express 是以文件目录的形式来定义类型的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.configure(function(){
  app.set(&amp;#39;port&amp;#39;, process.env.PORT || 3000);
  app.set(&amp;#39;views&amp;#39;, __dirname + &amp;#39;/views&amp;#39;);
  app.set(&amp;#39;view engine&amp;#39;, &amp;#39;jade&amp;#39;);
  app.use(express.favicon());
  app.use(express.logger(&amp;#39;dev&amp;#39;));
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(app.router);
  app.use(express.static(path.join(__dirname, &amp;#39;public&amp;#39;)));
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是对 express 的配置。&lt;/p&gt;

&lt;p&gt;接下来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get(&amp;#39;/&amp;#39;, routes.index);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一行就是对刚才访问到的主页的处理。&lt;/p&gt;

&lt;p&gt;最后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.createServer(app).listen(app.get(&amp;#39;port&amp;#39;), function(){
  console.log(&amp;quot;Express server listening on port &amp;quot; + app.get(&amp;#39;port&amp;#39;));
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是服务器的创建，因为 Node.js 运行环境本身可以作为 web server，所以不用 apache/nginx 等类似的 web server.&lt;/p&gt;

&lt;p&gt;我们的程序结构用 MVC + Routes，类似 Ruby on Rails, 但是我们只是需要的是 iOS 端获得 JSON 数据，所以我们可以去掉 View 这一层（删掉 views 目录）。&lt;/p&gt;

&lt;p&gt;然后新建 models 和 conterllers 目录，分别在刚建的目录里新建 note.js 文件。&lt;/p&gt;

&lt;p&gt;我喜欢用单个文件来做 URL 路由， 所以删除了 routes 目录，新建 routes.js 代替。&lt;/p&gt;

&lt;p&gt;在 &lt;strong&gt;controllers/note.js&lt;/strong&gt; 写上如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.index = function (req, res) {
  res.send(&amp;#39;hello world&amp;#39;);
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;strong&gt;routes.js&lt;/strong&gt; 写下如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var note = require(&amp;#39;./controllers/note&amp;#39;)

exports.route = function (app) {
  app.get(&amp;#39;/&amp;#39;, function(req, res) {
    res.send(&amp;#39;hello world&amp;#39;);
  });
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后在 &lt;strong&gt;app.js&lt;/strong&gt; 中 把那些 express 的默认建立的 user 变量删除，然后用以下代码替换原来的路由代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routes.route(app);
// app.get(&amp;#39;/&amp;#39;, routes.index);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重新启动 Server (node app.js)，我们就可以看到主页只输出 hello world 字符串。&lt;/p&gt;

&lt;h5 id='model'&gt;创建Model&lt;/h5&gt;

&lt;p&gt;mongoose 这个库管理 MongoDB 听方便的，在 &lt;strong&gt;/models/note.js&lt;/strong&gt; 里写下如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var mongoose = require(&amp;#39;mongoose&amp;#39;);
var db = mongoose.createConnection(&amp;#39;mongodb://localhost/notes&amp;#39;)
var NoteSchema = mongoose.Schema({
  title: String,
  content: String,
  author: String
});

exports.Note = db.model(&amp;#39;Note&amp;#39;,NoteSchema);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们在 &lt;strong&gt;/controllers/note.js&lt;/strong&gt; 里用一句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Note = require(&amp;#39;../models/note&amp;#39;).Note;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来引入 Note 这个 model，之后在这个 controller 里就能新建 Note 对象了。&lt;/p&gt;

&lt;h5 id='id16'&gt;创建路由&lt;/h5&gt;

&lt;p&gt;在 &lt;strong&gt;routes.js&lt;/strong&gt; 里追加如下 API&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var note = require(&amp;#39;./controllers/note&amp;#39;)

exports.route = function (app) {
  app.get(&amp;#39;/&amp;#39;, function(req, res) {
    res.send(&amp;#39;hello world&amp;#39;);
  });
  app.get(&amp;#39;/notes&amp;#39;, note.index);
  app.get(&amp;#39;/note/:id&amp;#39;, note.show);
  app.post(&amp;#39;/notes&amp;#39;, note.create);
  app.delete(&amp;#39;/note/:id&amp;#39;, note.destroy);
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个就是获取 note 列表。&lt;/p&gt;

&lt;p&gt;第二个是得到一个 note 的详细信息（不过咱这个 demo 直接一个列表就有了详细信息）。&lt;/p&gt;

&lt;p&gt;第三个是新建一个 note.&lt;/p&gt;

&lt;p&gt;第四个是删除一个对应 id 的 note.&lt;/p&gt;

&lt;h5 id='_controller'&gt;最后一步，完善 Controller&lt;/h5&gt;

&lt;p&gt;在之前一步我们看到了 每个 API 都调用了 controller 里的相应方法, 打开 &lt;strong&gt;./controllers/note&lt;/strong&gt; 输入如下代码&lt;/p&gt;

&lt;p&gt;var Note = require(&amp;#8216;../models/note&amp;#8217;).Note;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.index = function(req, res) {
  Note.find(function(err, notes) {
	if (!err) {
		res.send(notes);
	} else {
		res.send(err);
	}
  });
}

exports.show = function(req, res) {
  Note.findById(req.params.id, function (err, note) {
    if (!err) {
      res.send({success: 1, note: note});
    } else {
	  res.send({success: 0});
    }
  });
}

exports.create = function(req, res) {
  var note = new Note();
  note.title = req.body.title;
  note.content = req.body.content;
  note.author = req.body.author;
  console.log(note);
  note.save(function(err){
	if (!err) {
		res.send({success: 1});
	} else {
		res.send({success: 0});
	}
  });
}

exports.destroy = function(req, res) {
  if (req.params.id) {
	res.send({success: 0, error: &amp;quot;Need &amp;lt;id&amp;gt; parameter.&amp;quot;});
  } else {
	Note.findById(req.params.id, function (err, note) {
      if (!err) {
        note.remove(function(err) {
      	  if (!err) {
      	  	res.send({success: 1});
      	  } else {
      		res.send({success: 0, error: &amp;quot;Failed to delete.&amp;quot;});
      	  }
        });
      } else {
    	res.send({success: 0, error: &amp;quot;Can&amp;#39;t find the note.&amp;quot;});
      }
    });
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id='id17'&gt;测试&lt;/h5&gt;

&lt;p&gt;由于我们使用了 MongoDB 作为数据库，我们需要先安装，使用 Homebrew 安装很方便，终端执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update
brew install mongodb&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装好后，在终端执行 &lt;strong&gt;mongod&lt;/strong&gt; 就可以开启数据库服务了。&lt;/p&gt;

&lt;p&gt;然后，我们先在终端执行 &lt;strong&gt;node app.js&lt;/strong&gt; 开启应用服务器。&lt;/p&gt;

&lt;p&gt;最后，可以写个脚本试一下创建一个 note, Ruby 代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;net/http&amp;#39;
response = Net::HTTP.post_form(URI.parse(&amp;#39;http://localhost:3000/notes&amp;#39;), 
                           {title: &amp;#39;hello world&amp;#39;,
                           	content: &amp;#39;hello big world&amp;#39;,
                           	author: &amp;#39;levey&amp;#39;})

puts response.body&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果输出 { &amp;#8220;success&amp;#8221;: 1 } ， 说明创建成功。&lt;/p&gt;

&lt;h5 id='__'&gt;歇会儿 &amp;amp; 接下来&lt;/h5&gt;

&lt;p&gt;至此，WhateverNote 的 Server 端的这几个 API 完成了，接下来的第二篇将是 iOS 客户端与刚写好的 Server 端的交互的教程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Have a nice day.&lt;/strong&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>从 Linode 导出 PostgreSQL 数据到 Heroku</title>
   <link href="http://levey.github.com/blog/2012/11/06/migrate-postgresql-data-from-linode-to-heroku.html"/>
   <updated>2012-11-06T00:00:00+08:00</updated>
   <id>http://levey.github.com/blog/2012/11/06/migrate-postgresql-data-from-linode-to-heroku</id>
   <content type="html">&lt;p&gt;这篇博客意在帮助有想从 Linode 迁移网站到 Heroku 的读者.&lt;/p&gt;

&lt;p&gt;一星期前，我的网站 &lt;a href='http://coderxcoder.com'&gt;coderxcoder&lt;/a&gt; 想从 Linode 迁移到 Heroku, 本来像尝试 使 用 ruby 的 taps 这个 gem 来迁移，但是无奈失败多次，最后使用此篇博客中的方法。&lt;/p&gt;

&lt;p&gt;本篇使用到的手段有:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 &lt;a href='http://www.postgresql.org/docs/7.3/static/app-pgdump.html'&gt;pg_dump&lt;/a&gt; 备份 PostgreSQL 数据。&lt;/li&gt;

&lt;li&gt;Nginx 公开备份好的文件。&lt;/li&gt;

&lt;li&gt;使用 &lt;a href='https://devcenter.heroku.com/articles/pgbackups'&gt;pgbackups&lt;/a&gt; 这个 Heroku 的插件来导入并更新数据库。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id='1'&gt;1.备份数据库&lt;/h5&gt;

&lt;p&gt;首先 SSH 连接到 Linode 服务器, 输入命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PGPASSWORD=[您的PG密码] pg_dump -Fc --no-acl --no-owner -h 127.0.0.1 -U [您的PG用户名] 
[需要导出的数据库名] &amp;gt; mydb.dump&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出的 mydb.dump 就是 之后需要用到的备份文件。&lt;/p&gt;

&lt;h5 id='2_nginx_'&gt;2. Nginx 公开数据库备份文件&lt;/h5&gt;

&lt;p&gt;首先， 在 /var/www 里新建一个 dbbackup 的目录下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir /var/www/dbbackup&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后， 在 /etc/nginx/sites-available 目录下 新建一个 dbbackup.conf 的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo touch /etc/nginx/sites-available/dbbackup.conf&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再然后， 在 dbbackup.conf 里输入以下配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server
{
	server_name [你的服务器的域名或者IP];
	listen 7000;
	access_log off;
	root /var/www/dbbackup;

	location  /  {
    	autoindex  on;
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再然后，链接到 sites-enabled 目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s /etc/nginx/sites-available/dbbackup.conf /etc/nginx/sites-enabled/dbbackup.conf&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再然后，重启 nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo /etc/init.d/ngnix restart&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id='3_'&gt;3. 恢复数据库&lt;/h5&gt;

&lt;p&gt;这个很简单，按照 Heroku 的教程就好了，在你的项目目录里&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;heroku pgbackups:restore [数据库名] [第二步公开的数据库备份文件地址]&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 
</feed>
