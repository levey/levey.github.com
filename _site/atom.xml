<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Levey</title>
 <link href="http://levey.github.com/atom.xml" rel="self"/>
 <link href="http://levey.github.com/"/>
 <updated>2012-12-20T12:38:11+08:00</updated>
 <id>http://levey.github.com/</id>
 <author>
   <name>Levey</name>
   <email>levey.zhu@gmail.com</email>
 </author>

 
 <entry>
   <title>Delegate vs Blcok vs Notification vs KVO</title>
   <link href="http://levey.github.com/blog/2012/12/20/delegate-vs-blcok-vs-notification-vs-kvo.html"/>
   <updated>2012-12-20T00:00:00+08:00</updated>
   <id>http://levey.github.com/blog/2012/12/20/delegate-vs-blcok-vs-notification-vs-kvo</id>
   <content type="html">&lt;p&gt;最近在工作中遇到对使用 Delegate 和 Notification 的争议，我写下了自己的观点。&lt;/p&gt;

&lt;h4 id='delegate'&gt;Delegate&lt;/h4&gt;

&lt;h5 id='id14'&gt;好处&lt;/h5&gt;

&lt;p&gt;语法严格，所有方法必须被定义。&lt;/p&gt;

&lt;p&gt;编译期的检查，Warning 或者 Error。&lt;/p&gt;

&lt;p&gt;非常容易追踪，DEBUG 或者跳转到定义的时候很方便。&lt;/p&gt;

&lt;h5 id='id15'&gt;坏处&lt;/h5&gt;

&lt;p&gt;写的代码比较多。&lt;/p&gt;

&lt;p&gt;需要检查 delegate 是否为空指针。&lt;/p&gt;

&lt;p&gt;一对多实现困难。&lt;/p&gt;

&lt;h4 id='block'&gt;Block&lt;/h4&gt;

&lt;h5 id='id16'&gt;好处&lt;/h5&gt;

&lt;p&gt;匿名方法，不需要额外定义方法。&lt;/p&gt;

&lt;p&gt;异步处理时的语法直观。&lt;/p&gt;

&lt;h5 id='id17'&gt;坏处&lt;/h5&gt;

&lt;p&gt;需要小心 retain cycle.&lt;/p&gt;

&lt;p&gt;传入 block 的对象需要做处理。&lt;/p&gt;

&lt;h4 id='notification'&gt;Notification&lt;/h4&gt;

&lt;h5 id='id18'&gt;好处&lt;/h5&gt;

&lt;p&gt;实现简单。&lt;/p&gt;

&lt;p&gt;更新多个对象。&lt;/p&gt;

&lt;h5 id='id19'&gt;坏处&lt;/h5&gt;

&lt;p&gt;没有编译时检查。&lt;/p&gt;

&lt;p&gt;在不需要的时候需要注销通知。&lt;/p&gt;

&lt;p&gt;不可追踪（DEBUG）。&lt;/p&gt;

&lt;p&gt;通知的名字需要在 controller 和 observer 都被知道,如果稍有写错,后果不堪。&lt;/p&gt;

&lt;h4 id='kvo'&gt;KVO&lt;/h4&gt;

&lt;h5 id='id20'&gt;好处&lt;/h5&gt;

&lt;p&gt;在2个对象间同步信息很方便。&lt;/p&gt;

&lt;p&gt;能提供一个对象的新的值和旧的值。&lt;/p&gt;

&lt;p&gt;可以 observe 嵌套的对象。&lt;/p&gt;

&lt;h5 id='id21'&gt;坏处&lt;/h5&gt;

&lt;p&gt;被监听的属性是需要用字符串来表示的，没有编译期间检查。&lt;/p&gt;

&lt;p&gt;属性的改动导致 observe 失效。&lt;/p&gt;

&lt;p&gt;在对象销毁的时候需要移除 observer。&lt;/p&gt;

&lt;h4 id='id22'&gt;总结&lt;/h4&gt;

&lt;p&gt;我个人比较倾向于使用 Delegate 和 Block 来在各对象之前交互（在有多个方法的时候我会使用Delegate）在少数需要更新多个对象的使用 Notification 和 KVO.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Objective-C / Node.js 贯穿 iOS app 前后端教程(一)</title>
   <link href="http://levey.github.com/blog/2012/12/13/build-ios-app-with-nodejs-server-1.html"/>
   <updated>2012-12-13T00:00:00+08:00</updated>
   <id>http://levey.github.com/blog/2012/12/13/build-ios-app-with-nodejs-server-1</id>
   <content type="html">&lt;h4 id='id12'&gt;说明&lt;/h4&gt;

&lt;p&gt;这是一篇很基础的教程，全篇通过制作一个叫 WhateverNote 的 app，来描述 iOS app 的前端和服务端交互的。&lt;/p&gt;

&lt;h4 id='__'&gt;语言 / 框架&lt;/h4&gt;

&lt;p&gt;iOS 端用到的语言就是 Objective-C, 为了方便我选择 &lt;a href='https://github.com/AFNetworking/AFNetworking'&gt;AFNetowrking&lt;/a&gt; 作为 HTTP 库 。服务器端本来想用 Ruby on Rails 或者 Sinatra 的，但是后来想试一试 Node.js 的体验，所以就用 Node.js了，选择的 web framework 是 express.js, 跟 Sinatra 是类似的，都比较轻量级。&lt;/p&gt;

&lt;h4 id='id13'&gt;工具&lt;/h4&gt;

&lt;p&gt;iOS: &lt;code&gt;Xcode&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Node.js: &lt;code&gt;Sublime Text 2&lt;/code&gt; / &lt;code&gt; iTerm 2&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id='whatevernote__server'&gt;WhateverNote - Server&lt;/h4&gt;

&lt;p&gt;先从 &lt;a href='http://nodejs.org'&gt;http://nodejs.org&lt;/a&gt; 下载安装 Node.js，我当前的最新稳定版本为 v0.8.15。&lt;/p&gt;

&lt;p&gt;安装 Node.js 成功后，通过终端安装 experess.js, -g 参数表示安装的包为全局的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g express&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 express.js 成功后， 在 WhateverNote 目录下新建一个 Whatever-server 的项目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;express Whatever-server&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入刚建立的项目的目录 执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node app.js &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用浏览器打开 localhost:3000 就能看到 express 的欢迎页面了。&lt;/p&gt;

&lt;p&gt;然后我们看一下 app.js 这个文件，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&amp;#39;express&amp;#39;)
 , routes = require(&amp;#39;./routes&amp;#39;)
 , user = require(&amp;#39;./routes/user&amp;#39;)
 , http = require(&amp;#39;http&amp;#39;)
 , path = require(&amp;#39;path&amp;#39;);

var app = express();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是一些变量，express 是以文件目录的形式来定义类型的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.configure(function(){
  app.set(&amp;#39;port&amp;#39;, process.env.PORT || 3000);
  app.set(&amp;#39;views&amp;#39;, __dirname + &amp;#39;/views&amp;#39;);
  app.set(&amp;#39;view engine&amp;#39;, &amp;#39;jade&amp;#39;);
  app.use(express.favicon());
  app.use(express.logger(&amp;#39;dev&amp;#39;));
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(app.router);
  app.use(express.static(path.join(__dirname, &amp;#39;public&amp;#39;)));
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是对 express 的配置。&lt;/p&gt;

&lt;p&gt;接下来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get(&amp;#39;/&amp;#39;, routes.index);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一行就是对刚才访问到的主页的处理。&lt;/p&gt;

&lt;p&gt;最后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.createServer(app).listen(app.get(&amp;#39;port&amp;#39;), function(){
  console.log(&amp;quot;Express server listening on port &amp;quot; + app.get(&amp;#39;port&amp;#39;));
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是服务器的创建，因为 Node.js 运行环境本身可以作为 web server，所以不用 apache/nginx 等类似的 web server.&lt;/p&gt;

&lt;p&gt;我们的程序结构用 MVC + Routes，类似 Ruby on Rails, 但是我们只是需要的是 iOS 端获得 JSON 数据，所以我们可以去掉 View 这一层（删掉 views 目录）。&lt;/p&gt;

&lt;p&gt;然后新建 models 和 conterllers 目录，分别在刚建的目录里新建 note.js 文件。&lt;/p&gt;

&lt;p&gt;我喜欢用单个文件来做 URL 路由， 所以删除了 routes 目录，新建 routes.js 代替。&lt;/p&gt;

&lt;p&gt;在 &lt;strong&gt;controllers/note.js&lt;/strong&gt; 写上如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.index = function (req, res) {
  res.send(&amp;#39;hello world&amp;#39;);
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;strong&gt;routes.js&lt;/strong&gt; 写下如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var note = require(&amp;#39;./controllers/note&amp;#39;)

exports.route = function (app) {
  app.get(&amp;#39;/notes&amp;#39;, note.index);
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后在 &lt;strong&gt;app.js&lt;/strong&gt; 中 把那些 express 的默认建立的 user 变量删除，然后用以下代码替换原来的路由代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;routes.route(app);
// app.get(&amp;#39;/&amp;#39;, routes.index);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重新启动 Server (node app.js)，我们就可以看到主页只输出 hello world 字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- - 未完待续&lt;/strong&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>从 Linode 导出 PostgreSQL 数据到 Heroku</title>
   <link href="http://levey.github.com/blog/2012/11/06/migrate-postgresql-data-from-linode-to-heroku.html"/>
   <updated>2012-11-06T00:00:00+08:00</updated>
   <id>http://levey.github.com/blog/2012/11/06/migrate-postgresql-data-from-linode-to-heroku</id>
   <content type="html">&lt;p&gt;这篇博客意在帮助有想从 Linode 迁移网站到 Heroku 的读者.&lt;/p&gt;

&lt;p&gt;一星期前，我的网站 &lt;a href='http://coderxcoder.com'&gt;coderxcoder&lt;/a&gt; 想从 Linode 迁移到 Heroku, 本来像尝试 使 用 ruby 的 taps 这个 gem 来迁移，但是无奈失败多次，最后使用此篇博客中的方法。&lt;/p&gt;

&lt;p&gt;本篇使用到的手段有:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 &lt;a href='http://www.postgresql.org/docs/7.3/static/app-pgdump.html'&gt;pg_dump&lt;/a&gt; 备份 PostgreSQL 数据。&lt;/li&gt;

&lt;li&gt;Nginx 公开备份好的文件。&lt;/li&gt;

&lt;li&gt;使用 &lt;a href='https://devcenter.heroku.com/articles/pgbackups'&gt;pgbackups&lt;/a&gt; 这个 Heroku 的插件来导入并更新数据库。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id='1'&gt;1.备份数据库&lt;/h5&gt;

&lt;p&gt;首先 SSH 连接到 Linode 服务器, 输入命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PGPASSWORD=[您的PG密码] pg_dump -Fc --no-acl --no-owner -h 127.0.0.1 -U [您的PG用户名] 
[需要导出的数据库名] &amp;gt; mydb.dump&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出的 mydb.dump 就是 之后需要用到的备份文件。&lt;/p&gt;

&lt;h5 id='2_nginx_'&gt;2. Nginx 公开数据库备份文件&lt;/h5&gt;

&lt;p&gt;首先， 在 /var/www 里新建一个 dbbackup 的目录下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir /var/www/dbbackup&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后， 在 /etc/nginx/sites-available 目录下 新建一个 dbbackup.conf 的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo touch /etc/nginx/sites-available/dbbackup.conf&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再然后， 在 dbbackup.conf 里输入以下配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server
{
	server_name [你的服务器的域名或者IP];
	listen 7000;
	access_log off;
	root /var/www/dbbackup;

	location  /  {
    	autoindex  on;
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再然后，链接到 sites-enabled 目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s /etc/nginx/sites-available/dbbackup.conf /etc/nginx/sites-enabled/dbbackup.conf&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再然后，重启 nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo /etc/init.d/ngnix restart&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id='3_'&gt;3. 恢复数据库&lt;/h5&gt;

&lt;p&gt;这个很简单，按照 Heroku 的教程就好了，在你的项目目录里&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;heroku pgbackups:restore [数据库名] [第二步公开的数据库备份文件地址]&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 
</feed>
